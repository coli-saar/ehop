import io
import re
import sys
import traceback
from contextlib import redirect_stdout

import func_timeout


def extract_csloi(response: str) -> list[int]:
    """
    Extracts a comma-separated list of integers from a string.
    To be used for extracting a list of integers from an LLM response.

    Behavior:
    If multiple lines contain numbers, only the last line is used.
    If no lines contain numbers, an empty list is returned.
    """
    # filter for lines that have a number in them
    relevant_lines = list(
        filter(
            lambda line: re.match(pattern=r".*\d+.*", string=line),
            response.strip().split("\n"),
        )
    )

    if not relevant_lines:
        return []

    # remove whitespace
    line = "".join(relevant_lines[-1].split())

    # remove everything past the last digit
    while line and not line[-1].isnumeric():
        line = line[:-1]

    # remove everything up to the last non-[digit/comma/space] character
    line = re.split(r"[^\d, ]", line)[-1]

    comma_separated_list = line.split(",")  # split on commas

    # filter for actual numbers and cast to int
    pattern = re.compile(r"^\d+$")
    integers = [int(elem) for elem in comma_separated_list if pattern.match(elem)]

    return integers


def extract_code(response: str) -> str:
    """
    Extracts the code from an LLM response.
    """
    sections = response.split("```")
    n = len(sections)
    if n == 1:
        return sections[0].strip()
    else:
        # if the number of sections is odd, the code is in the second-to-last section
        # if the number of sections is even, we assume the code was cut off and is in the last section
        code = sections[n - 2] if n % 2 == 1 else sections[n - 1]
        return code.split("\n", 1)[1].strip()


def extract_lp_code(response: str) -> str:
    """
    Extracts LP code from an LLM response.
    """
    code = extract_code(response)

    output = ""

    section = None

    # correct a few common formatting issues with generated LP code
    for line in code.split("\n"):
        if (
            section == "Subject To"
            and re.search(r"\s+(>|<|>=|<=|=)\s+(\d* *\S*[^\d\s]\S*)", line) is not None
        ):
            # move non-numeric terms to the left side of the inequality; e.g., "a < b" becomes "a - b < 0"
            output += re.sub(
                r"^(.+)\s+(>|<|>=|<=|=)\s+(\d* *\S*[^\d\s]\S*)([^\n]*)$",
                r"\1 - \3 \2 0\4\n",
                line,
            )
            continue
        elif section == "Bounds" and "," in line:
            matches = re.findall(r"[<>]=?", line)
            if len(matches) == 1:
                indent_match = re.match(r"\s*", line)
                indent = indent_match[0] if indent_match is not None else ""
                left, right = line.split(matches[0])
                left, right = left.strip(), right.strip()
                terms_on_left = "," in left
                new_lines = [
                    (
                        f"{indent}{term.strip()} {matches[0]} {right}"
                        if terms_on_left
                        else f"{indent}{left} {matches[0]} {term.strip()}"
                    )
                    for term in (left.split(",") if terms_on_left else right.split(","))
                ]
                output += "\n".join(new_lines) + "\n"
                continue
        elif re.match(r"\w+", line):
            section = line.strip()
        output += line + "\n"

    return output


def extract_python_code(
    response: str, whitelisted_imports: list[str] = ["gurobipy"]
) -> str:
    """
    Extracts Python code from an LLM response while checking that
    no disallowed imports are used (as an unsophisticated security measure).
    """
    code = extract_code(response)

    for line in code.split("\n"):
        if "import" in line and not any(
            line.strip() == f"import {imp}"
            or line.strip().startswith(f"from {imp} import")
            for imp in whitelisted_imports
        ):
            raise ValueError(f"The following import is not allowed:\n{line}")

    return code


def execute_generated_code(
    code_str: str, time_limit: float = 60
) -> tuple[str, str | None]:
    """
    Executes code generated by an LLM and returns the (stripped) output and error (if any) as a tuple.
    WARNING: This function inherits the security risks of executing arbitrary code. Use with caution.
    """

    error = None

    with redirect_stdout(io.StringIO()) as output:
        try:
            func_timeout.func_timeout(time_limit, exec, args=(code_str, {}))
        # the following error handling is adapted from https://stackoverflow.com/a/28836286/19048626
        except SyntaxError as err:
            error_class = err.__class__.__name__
            detail = err.args[0] if err.args else ""
            line_number = err.lineno
            error = f"{error_class} at line {line_number}: {detail}"
        except Exception as err:
            error_class = err.__class__.__name__
            detail = err.args[0] if err.args else ""
            _, _, tb = sys.exc_info()
            line_number = traceback.extract_tb(tb)[-1][1]
            error = f"{error_class} at line {line_number}: {detail}"
        # func_timeout isn't caught by the general Exception handler, so we need to catch it separately below
        except func_timeout.exceptions.FunctionTimedOut as err:
            error = f"TimeoutError: Code execution took too long (more than {time_limit} second{'s' if time_limit == 1 else ''})."

    return output.getvalue().strip(), error
